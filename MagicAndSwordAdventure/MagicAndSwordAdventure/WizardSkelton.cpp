#include "WizardSkelton.h"

namespace
{
	constexpr VECTOR kLeftDir = { 0.0,90.0f * DX_PI_F / 180.0f,0.0f }; // 左向き
	constexpr VECTOR kRightDir = { 0.0,270.0f * DX_PI_F / 180.0f,0.0f }; // 右向き
	constexpr float kColRadius = 25.0f; // 敵本体の当たり判定
	constexpr float kSerchRange = 500.0f; // 索敵範囲
	constexpr float kAttackRange = 400.0f; // 攻撃範囲
	constexpr float kMoveSpeed = 4.0f; // 移動速度
	constexpr float kAttackSpeed = 2.5f; // 移動速度
	constexpr float kDebugOffSet = 45.0f;
	constexpr float kMoveAccRate = 1.1f;// 加速
	constexpr float kMoveDecRate = 0.80f;// 減速
	constexpr float kDefaultAttackCoolTime = 120.0f;
	constexpr float kAttackDuration = 60.0f; // 攻撃の持続時間
	// アニメーションの番号
	constexpr int kIdleAnimNo = 41;
	constexpr int kWalkAnimNo = 54;
	constexpr int kSpellCastAnimNo = 76;
	constexpr int kAttackAnimNo = 77;
	constexpr int kDamageAnimNo = 40;
	constexpr int kDeathAnimNo = 25;
	// アニメーションの速度
	constexpr float kAnimSpeedFast = 0.5f; // 短めの再生の時
	constexpr float kAnimSpeedMedium = 0.7f; // 中程度のテンポ
	constexpr float kAnimSpeedDeath = 0.4f; // 死亡時の再生速度
	// 最大HP
	constexpr int kMaxHp = 80;
	constexpr int kMaxHomingTime = 60; // 追尾する時間
	// 攻撃力
	constexpr int kPower = 20;
	// 吹き飛んでいる時間
	constexpr float kKnockBackSpeed = 5.0f;
	constexpr float kKnockbackDuration = 0.5f;
	// 攻撃の範囲
	constexpr float kAttackRadius = 20.0f;
	constexpr float kAttckOffSetX = 30.0f;
	constexpr float kAttckOffSetY = 40.0f;
	// モデルのスケールサイズ
	constexpr float kScaleSize = 45.0f;
	constexpr float kBarrelScaleSize = 0.25f;
	// 撃破スコア
	constexpr int kDestroyScore = 300;
	// 死亡後のポジションのオフセット
	constexpr float kDeadPosY = -1000.0f;
	// 秒数変換
	constexpr float kFramesPerSecond = 60.0f;
	//int attackCount = 0;
}

WizardSkelton::WizardSkelton():
m_toPlayerDir({0.0f,0.0f,0.0f}),
m_isAttackEnd(false),
m_attack({ 0.0f,{m_pos.x - m_attack.attackOffSetX,0,m_pos.z},false,0,0,0,0.0f,0.0f,0.0f }),
m_isCasting(false),
m_isCastFinished(false),
m_barrelHandle(-1),
m_rollAngleZ(0.0f),
m_attackDir({0.0f,0.0f,0.0f}),
m_homingTimer(0),
m_isTrackFlag(false),
m_attackCount(0)
{
}

void WizardSkelton::Init(std::shared_ptr<Player> pPlayer, VECTOR pos, std::shared_ptr<ScoreManager> pScoreManager)
{
	m_pPlayer = pPlayer;
	m_pScoreManager = pScoreManager;
	m_pos = { 0.0f,0.0f,0.0f };
	m_pos = VAdd(m_pos, pos);
	m_attack.pos = VGet(m_pos.x - m_attack.attackOffSetX, 0, m_pos.z);
	m_modelHandle = MV1LoadModel("Data/model/Skeleton_Mage.mv1");
	m_barrelHandle = MV1LoadModel("Data/model/barrel_large.mv1");
	m_attack.attackCoolTime = -1.0f;
	m_attack.timer = kAttackDuration;
	m_isDying = false;
	m_isDead = false;
	m_hp = kMaxHp;
	m_power = kPower;
	m_knockbackDir = { 0.0f,0.0f,0.0f };
	m_knockbackTimer = 0.0f;
	MV1SetScale(m_modelHandle, VGet(kScaleSize, kScaleSize, kScaleSize));
	MV1SetRotationXYZ(m_modelHandle, kLeftDir);
	AttachAnim(m_modelHandle, kIdleAnimNo);
	m_destroyScore = kDestroyScore;
	m_attack = { kAttackRadius,{m_pos.x - m_attack.attackOffSetX,0,m_pos.z},false,0,0,kAttackDuration,kAttckOffSetX,kAttckOffSetY,kDefaultAttackCoolTime };
	m_attackCount = 0;
	m_isTrackFlag = false;
}

void WizardSkelton::End()
{
	MV1DeleteModel(m_modelHandle);
	MV1DeleteModel(m_barrelHandle);
	m_attack.pos = { m_attack.pos.x,m_attack.pos.y - 1000.0f,m_attack.pos.z };
	m_attack.active = false;
	m_pos = { m_pos.x,m_pos.y + kDeadPosY,m_pos.z };
	m_isTrackFlag = false;
}

void WizardSkelton::Update()
{
	if(m_isDying)
	{
		OnDeath();
		return;
	}
	if (!m_isDead)
	{
		m_enemyToPlayer = VSub(m_pPlayer->GetPos(),m_pos);
		// エネミーからプレイヤーまでの距離の大きさ
		m_enemyToPlayerDistance = VSize(m_enemyToPlayer);
		//printfDx(L"m_enemyToPlayerDistance:%f\n",m_enemyToPlayerDistance);
		
		// 索敵範囲内に入ったら攻撃する
		if (m_enemyToPlayerDistance < kSerchRange && m_attack.attackCoolTime < 0 && !m_attack.active && !m_isCasting)
		{
			m_isCasting = true;
			m_isCastFinished = false;
			ChangeAnim(m_modelHandle,kSpellCastAnimNo,false, kAnimSpeedMedium);
		}
		if (m_isCasting && !m_isCastFinished && GetIsAnimEnd()) // 予備動作が終わったら攻撃に移る
		{
			m_isCastFinished = true;
			m_isCasting = false;
			m_attack.active = true;
			ChangeAnim(m_modelHandle, kAttackAnimNo, false, kAnimSpeedFast);
		}
		if (m_attack.active)
		{
			DoAttack();
			m_rollAngleZ += 0.1f; // 弾の回転を進める
			if (m_rollAngleZ > DX_PI_F*2.0f)
			{
				m_rollAngleZ -= DX_PI_F * 2.0f; // 360度を超えたら0度に戻す
			}
			m_attack.timer--;
			if (VSize(VSub(m_attack.pos, m_pos)) > kAttackRange) // 攻撃の範囲を超えたら攻撃をリセット
			{
				m_attack.active = false;
				m_attack.pos = { m_pos.x,-1000.0f,m_pos.z };
				ChangeAnim(m_modelHandle, kIdleAnimNo, false, kAnimSpeedFast);
				m_attack.timer = kAttackDuration;
				m_attack.attackCoolTime = kDefaultAttackCoolTime; // 再度クールタイムを設定
				m_attackCount = 0;
				m_isAttackEnd = false;
			}
		}
		else
		{
			// 攻撃が終わっているならクールタイムを減らす
			m_attack.attackCoolTime--;
		}
		if (GetIsAnimEnd())
		{
			ChangeAnim(m_modelHandle, kIdleAnimNo, false, kAnimSpeedFast);
		}
		MV1SetPosition(m_modelHandle, m_pos);
		UpdateAnim();
	}
	else
	{
		End();
		return;
	}
}

void WizardSkelton::DoAttack()
{
	if (m_isDying || m_isDead) return;
	
	// プレイヤーに向かうベクトル
	m_toPlayerDir = VNorm(VSub(m_pPlayer->GetPos(), m_pos));
	if (m_attackCount == 0) // m_attackCountが0から1になるときを攻撃開始フレームとする
	{
		m_attack.active = true;
		m_attackDir = VNorm(VSub(m_pPlayer->GetPos(), m_pos)); // 攻撃の初期方向を計算
		m_homingTimer = kMaxHomingTime; // 追尾タイマーをセット
	}
	m_attackCount++;
	if (m_homingTimer > 0) // 追尾タイマーが残っている間はベクトルを更新する
	{
		m_attackDir = VNorm(VSub(m_pPlayer->GetPos(), m_pos)); // プレイヤーに向かうベクトルを更新
		m_homingTimer--; // タイマーを減らす
	}
	if (m_enemyToPlayer.x > 0)
	{
		MV1SetRotationXYZ(m_modelHandle, kRightDir);
	}
	else
	{
		MV1SetRotationXYZ(m_modelHandle, kLeftDir);
	}
	// プレイヤーの位置に向かって攻撃を飛ばす
	m_attack.pos.x += m_attackDir.x * kAttackSpeed * kMoveAccRate;
	m_attack.pos.z += m_attackDir.z * kAttackSpeed * kMoveAccRate;
	m_attack.pos.y = 20.0f;

	MV1SetPosition(m_barrelHandle,m_attack.pos);
	MV1SetRotationXYZ(m_barrelHandle, VGet(DX_PI_F / 2.0f + DX_PI_F, 0.0f, m_rollAngleZ));
	MV1SetScale(m_barrelHandle, VGet(kBarrelScaleSize, kBarrelScaleSize, kBarrelScaleSize));
}

void WizardSkelton::OnDamage()
{
	if (m_isDying || m_isDead) return;
	if (m_enemyToPlayer.x > 0)
	{
		m_pos.x += 1.0f;
	}
	else
	{
		m_pos.x -= 1.0f;
	}
	ChangeAnim(m_modelHandle, kDamageAnimNo, false, kAnimSpeedFast);
	m_hp -= m_pPlayer->GetPower();
	if (m_hp <= 0 && !m_isDying)
	{
		m_hp = 0;
		m_isDying = true;
		// 吹き飛ぶ方向を決める
		m_knockbackDir = VNorm(VSub(m_pos, m_pPlayer->GetPos()));
		// タイマーをセット
		m_knockbackTimer = kKnockbackDuration;
		ChangeAnim(m_modelHandle, kDeathAnimNo, false, kAnimSpeedDeath);
	}
	if (m_hp <= 0)
	{
		m_hp = 0;
	}
	//printfDx(L"hp:%d\n", m_hp);
}

void WizardSkelton::OnDeath()
{
	if (m_knockbackTimer > 0.0f)
	{
		m_pos = VAdd(m_pos, VScale(m_knockbackDir, kKnockBackSpeed));
		m_knockbackTimer -= 1.0f / kFramesPerSecond; // m_knockbackTimerを減少
	}
	if (GetIsAnimEnd())
	{
		m_isDead = true;
		m_isDying = false;
		m_pScoreManager->AddScore(m_destroyScore);
	}
	MV1SetPosition(m_modelHandle, m_pos);
	UpdateAnim();
}

void WizardSkelton::Draw() const
{
	MV1DrawModel(m_modelHandle);
	if (m_attack.active && !m_isDying)
	{
		//DrawSphere3D(attack.pos, attack.radius, 8, 0x0000ff, 0xffffff, true);
		MV1DrawModel(m_barrelHandle);
	}
#if _DEBUG
	/*DrawSphere3D(VGet(m_pos.x, m_pos.y + kDebugOffSet, m_pos.z), kColRadius, 8, 0xff0000, 0xffffff, false);
	DrawSphere3D(VGet(m_pos.x, m_pos.y + kDebugOffSet, m_pos.z), kSerchRange, 8, 0xffff00, 0xffffff, false);*/
#endif
}

bool WizardSkelton::IsAttackActive() const
{
	return m_attack.active; 
}

void WizardSkelton::TrackPlayer()
{
	m_toPlayerDir = VNorm(VSub(m_pPlayer->GetPos(), m_pos));
	m_pos.x += m_toPlayerDir.x * kMoveSpeed * kMoveDecRate;
	m_pos.z += m_toPlayerDir.z * kMoveSpeed * kMoveDecRate;
	if (m_enemyToPlayer.x > 0)
	{
		MV1SetRotationXYZ(m_modelHandle, kRightDir);
	}
	else
	{
		MV1SetRotationXYZ(m_modelHandle, kLeftDir);
	}
	// 移動アニメーション
	ChangeAnim(m_modelHandle, kWalkAnimNo, true, kAnimSpeedFast);
}
